tools:
  - name: generate-tool
    description: A tool that generates other tools based on descriptions.
    type: python
    content: |
      import os
      import logging
      from langchain_core.messages import HumanMessage
      from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
      from langgraph.graph import StateGraph, END
      from langchain_openai import ChatOpenAI
      from langchain_core.tools import tool
      from typing import List, Dict
      from typing_extensions import TypedDict

      os.environ["OPENAI_API_KEY"] = os.getenv("OPENAI_API_KEY")

      @tool
      def generate_tool_spec(description: str) -> str:
          examples = [
              {
                  "description": "A custom Python script",
                  "yaml": """
                  - name: custom-python-script
                    description: A custom Python script
                    type: python
                    content: |
                      import sys
                      import json

                      with open('/data/config.json') as f:
                          config = json.load(f)

                      print(f"Hello, {sys.argv[1]}!")
                      print("Config settings:", config)
                    dependencies: |
                      requests==2.25.1
                      numpy==1.21.0
                    args:
                      name:
                        description: Name to greet
                        required: true
                    env:
                      - PYTHON_ENV
                    with_files:
                      - path: /data/input.txt
                        content: "https://example.com/path/to/input.txt"
                      - path: /data/config.json
                        content: |
                          {
                            "setting1": "value1",
                            "setting2": "value2",
                            "token": "{{.MY_SECRET_TOKEN}}"
                          }
                  """
              },
              {
                  "description": "A custom Bash script",
                  "yaml": """
                  - name: custom-bash-script
                    description: A custom Bash script
                    type: bash
                    content: |
                      echo "Reading from file..."
                      cat /data/input.txt
                      echo "Hello, $name!"
                    args:
                      name:
                        description: Name to greet
                        required: true
                    with_files:
                      - path: /data/input.txt
                        content: "Hello from input file!"
                  """
              },
              {
                  "description": "A custom Golang script",
                  "yaml": """
                  - name: custom-golang-script
                    description: A custom Golang script
                    type: golang
                    content: |
                      package main

                      import (
                        "fmt"
                        "io/ioutil"
                        "log"
                        "encoding/json"
                      )

                      type Config struct {
                        Setting1 string `json:"setting1"`
                        Setting2 string `json:"setting2"`
                        Token    string `json:"token"`
                      }

                      func main() {
                        data, err := ioutil.ReadFile("/data/config.json")
                        if err != nil {
                          log.Fatalf("failed to read file: %v", err)
                        }

                        var config Config
                        if err := json.Unmarshal(data, &config); err {
                          log.Fatalf("failed to parse json: %v", err)
                        }

                        fmt.Println("Config settings:", config)
                        fmt.Println("Hello, {{.name}}!")
                      }
                    dependencies: |
                      module main
                      go 1.16
                      require (
                        github.com/gorilla/mux v1.8.0
                      )
                    args:
                      name:
                        description: Name to greet
                        required: true
                    with_files:
                      - path: /data/config.json
                        content: |
                          {
                            "setting1": "value1",
                            "setting2": "value2",
                            "token": "{{.MY_SECRET_TOKEN}}"
                          }
                  """
              },
              {
                  "description": "A custom Node.js script",
                  "yaml": """
                  - name: custom-nodejs-script
                    description: A custom Node.js script
                    type: nodejs
                    content: |
                      const fs = require('fs');

                      fs.readFile('/data/config.json', 'utf8', (err, data) => {
                        if (err) {
                          console.error(err);
                          return;
                        }
                        const config = JSON.parse(data);
                        console.log("Config settings:", config);
                      });

                      console.log('Hello, {{.name}}!');
                    dependencies: |
                      {
                        "name": "custom-nodejs-script",
                        "version": "1.0.0",
                        "dependencies": {
                          "express": "^4.17.1"
                        }
                      }
                    args:
                      name:
                        description: Name to greet
                        required: true
                    with_files:
                      - path: /data/config.json
                        content: |
                          {
                            "setting1": "value1",
                            "setting2": "value2",
                            "token": "{{.MY_SECRET_TOKEN}}"
                          }
                  """
              }
          ]

          for example in examples:
              if description.lower() in example["description"].lower():
                  return example["yaml"]
          return f"# Could not find a matching example for the description: {description}"

      def create_agent(model_name, tools, system_message: str):
          llm = ChatOpenAI(model=model_name)
          prompt = ChatPromptTemplate.from_messages(
              [
                  (
                      "system",
                      "You are a helpful AI assistant, collaborating with other assistants."
                      " Use the provided tools to progress towards answering the question."
                      " If you are unable to fully answer, that's OK, another assistant with different tools "
                      " will help where you left off. Execute what you can to make progress."
                      " If you or any of the other assistants have the final answer or deliverable,"
                      " prefix your response with FINAL ANSWER so the team knows to stop."
                      " You have access to the following tools: {tool_names}.\n{system_message}",
                  ),
                  MessagesPlaceholder(variable_name="messages"),
              ]
          )
          prompt = prompt.partial(system_message=system_message)
          prompt = prompt.partial(tool_names=", ".join([tool.name for tool in tools]))
          return prompt | llm.bind_tools(tools)

      class AgentState(TypedDict):
          messages: List[HumanMessage]
          sender: str

      import functools

      def agent_node(state: AgentState, agent, name: str) -> Dict:
          result = agent.invoke(state)
          return {
              "messages": [result],
              "sender": name,
          }

      pm_model = os.getenv("PM_MODEL", "gpt-4")
      product_manager = create_agent(
          pm_model,
          [generate_tool_spec],
          system_message="Clarify the tool description and ensure all necessary information is provided."
      )
      pm_node = functools.partial(agent_node, agent=product_manager, name="Product Manager")

      se_model = os.getenv("SE_MODEL", "gpt-4")
      software_engineer = create_agent(
          se_model,
          [generate_tool_spec],
          system_message="Generate the YAML schema for the tool based on the description."
      )
      se_node = functools.partial(agent_node, agent=software_engineer, name="Software Engineer")

      workflow = StateGraph(AgentState)

      workflow.add_node("Product Manager", pm_node)
      workflow.add_node("Software Engineer", se_node)

      from typing import Literal

      def router(state: AgentState) -> Literal["Software Engineer", "__end__"]:
          messages = state["messages"]
          last_message = messages[-1]
          if "FINAL ANSWER" in last_message.content:
              return "__end__"
          return "Software Engineer"

      workflow.add_conditional_edges(
          "Product Manager",
          router,
          {"Software Engineer": "Software Engineer", "__end__": END},
      )

      workflow.set_entry_point("Product Manager")
      graph = workflow.compile()

      def run_tool(description: str):
          events = graph.stream(
              {
                  "messages": [
                      HumanMessage(
                          content=description
                      )
                  ],
              },
              {"recursion_limit": 150},
          )
          for s in events:
              logging.info(s)
              logging.info("----")

      if __name__ == "__main__":
          import argparse
          parser = argparse.ArgumentParser(description='Generate a tool specification based on description.')
          parser.add_argument('--description', type=str, required=True, help='Description of the tool to generate')
          args = parser.parse_args()
          run_tool(args.description)
    dependencies: |
      langchain
      langchain_openai
      langsmith
      pandas
      langchain_experimental
      matplotlib
      langgraph
      langchain_core
    args:
      description:
        description: Description of the tool to generate
        required: true
    env:
      - OPENAI_API_KEY
      - OPENAI_API_BASE
